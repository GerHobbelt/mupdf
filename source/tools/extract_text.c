/*
Extracts text paragraphs from low-level XML representation of text spans, e.g.
as generated by 'mutool.py draw -F raw', and creates .docx file containing the
text paragraphs.

Build and test with:
    ./scripts/ptodoc.py

Run with -h or --help to see help.

Unless otherwise stated, all functions return 0 on success or -1 with errno
set.
*/

#include "mupdf/fitz.h"
#include "mupdf/ucdn.h"

#include <pthread.h>

#include <assert.h>
#include <errno.h>
#include <math.h>
#include <float.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include <sys/stat.h>
#include <sys/types.h>


/* Crudely #include the stext-device.c code. */
#include "../fitz/stext-device.c"


/* We do lots of string appending, currently by simply realloc-ing each time.
*/

/* Appends a char to a string. Returns 0, or -1 with errno set if realloc()
failed. */
static int str_catc(char** p, char c)
{
    int l = (*p) ? strlen(*p) : 0;
    l += 1;
    char* pp = realloc(*p, l+1);
    if (!pp)    return -1;
    *p = pp;
    (*p)[l-1] = c;
    (*p)[l] = 0;
    return 0;
}

/* Appends a string to a string. Returns 0, or +1 if realloc() failed. */
static int str_cat(char** p, const char* s)
{
    int l_old = (*p) ? strlen(*p) : 0;
    int l_new = strlen(s);
    char* pp = realloc(*p, l_old + l_new + 1);
    if (!pp)    return -1;
    memcpy(pp + l_old, s, l_new + 1);
    *p = pp;
    return 0;
}

/* Reads bytes until EOF and returns zero-terminated string in memory allocated
with realloc(). If error, we return NULL with errno set. */
static char* read_all(FILE* in)
{
    char*   ret = NULL;
    int     len = 0;
    size_t  delta = 128;
    for(;;) {
        char* p = realloc(ret, len + delta + 1);
        if (!p) {
            free(ret);
            return NULL;
        }
        ret = p;
        ssize_t n = fread(ret + len, 1 /*size*/, delta /*nmemb*/, in);
        len += n;
        if (feof(in)) {
            ret[len] = 0;
            return ret;
        }
    }
}


/* Things for representing XML. */

typedef struct {
    char*   name;
    char*   value;
} attribute_t;

/* Represents a single <...> XML tag plus trailing text. */
typedef struct {
    char*   name;
    attribute_t*    attributes;
    int             attributes_num;
    char*   text;
} tag_t;

static void tag_show(tag_t* tag, FILE* out)
{
    fprintf(out, "tag name=%s attributes_num=%i\n", tag->name, tag->attributes_num);
    int i;
    for (i=0; i<tag->attributes_num; ++i) {
        fprintf(out, "    %s=%s\n", tag->attributes[i].name, tag->attributes[i].value);
    }
}

static char* tag_attributes_find(tag_t* tag, const char* name)
{
    for (int i=0; i<tag->attributes_num; ++i) {
        if (!strcmp(tag->attributes[i].name, name)) {
            return tag->attributes[i].value;
        }
    }
    return NULL;
}

static int tag_attributes_find_int(tag_t* tag, const char* name, int default_)
{
    const char* value = tag_attributes_find(tag, name);
    if (!value) return default_;
    return atoi(value);
}

static float tag_attributes_find_float(tag_t* tag, const char* name)
{
    const char* value = tag_attributes_find(tag, name);
    if (!value) {
        fprintf(stderr, "cannot find attribute '%s'", name);
        tag_show(tag, stderr);
        assert(0);
    }
    return atof(value);
}

static int tag_attributes_append(tag_t* tag, char* name, char* value)
{
    attribute_t* a = realloc(
            tag->attributes,
            (tag->attributes_num+1) * sizeof(attribute_t)
            );
    if (!a) return +1;
    tag->attributes = a;
    tag->attributes[tag->attributes_num].name = name;
    tag->attributes[tag->attributes_num].value = value;
    tag->attributes_num += 1;
    return 0;
}

/* Sets all fields to NULL, so will cause memory leaks if fields have not been
freed. */
static void tag_init(tag_t* tag)
{
    tag->name = NULL;
    tag->attributes = NULL;
    tag->attributes_num = 0;
    tag->text = NULL;
}

static void tag_free(tag_t* tag)
{
    free(tag->name);
    free(tag->attributes);
    free(tag->text);
}

static void tag_reset(tag_t* tag)
{
    tag_free(tag);
    tag_init(tag);
}

/* Like strcmp() but also handles NULL. */
static int strcmp_null(const char* a, const char* b)
{
    if (!a && !b) return 0;
    if (!a) return -1;
    if (!b) return 1;
    return strcmp(a, b);
}

/* Compares tag name, then attributes; returns -1, 0 or +1. Does not compare
tag_t::text members. */
static int compare_tags(const tag_t* lhs, const tag_t* rhs)
{
    int d;
    d = strcmp_null(lhs->name, rhs->name);
    if (d)  return d;
    for(int i=0;; ++i) {
        if (i >= lhs->attributes_num || i >= rhs->attributes_num) {
            break;
        }
        const attribute_t* lhs_attribute = &lhs->attributes[i];
        const attribute_t* rhs_attribute = &rhs->attributes[i];
        d = strcmp_null(lhs_attribute->name, rhs_attribute->name);
        if (d)  return d;
        d = strcmp_null(lhs_attribute->value, rhs_attribute->value);
        if (d)  return d;
    }
    if (lhs->attributes_num > rhs->attributes_num) return +1;
    if (lhs->attributes_num < rhs->attributes_num) return -1;
    return 0;
}



/* pparse_*(): simple XML 'pull' parser.

pparse_init() merely consumes the initial '<'; thereafter pparse_next() always
consumes the next '<' before returning the previous tag.

Opens specified file, verifies that prefix is as expected. Returns NULL if
error. */
static FILE* pparse_init(const char* path)
{
    FILE* in = NULL;
    char* buffer = NULL;
    int e = 1;

    in = fopen(path, "r");
    if (!in) {
        fprintf(stderr, "%s:%i: error: Could not open mutool output filename=%s\n",
                __FILE__, __LINE__, path);
        goto end;
    }

    const char  prefix[] = "<?xml version=\"1.0\"?>\n";
    buffer = malloc(sizeof(prefix));
    if (!buffer) {
        fprintf(stderr, "%s:%i: error: malloc() failed\n", __FILE__, __LINE__);
        goto end;
    }
    ssize_t n = fread(buffer, sizeof(prefix)-1, 1 /*nmemb*/, in);
    if (n != 1) {
        fprintf(stderr, "%s:%i: error: fread() failed. n=%zi. path='%s'\n", __FILE__, __LINE__, n, path);
        goto end;
    }
    buffer[sizeof(prefix)-1] = 0;
    if (strcmp(prefix, buffer)) {
        fprintf(stderr, "Unrecognised prefix in path=%s: %s\n", path, buffer);
        goto end;
    }

    {
        int c = getc(in);
        if (c != '<') {
            fprintf(stderr, "Expected '<' but found c=%i\n", c);
            goto end;
        }
    }
    e = 0;

    end:
    free(buffer);
    if (e) {
        if (in) {
            fclose(in);
            in = NULL;
        }
    }
    return in;
}

/* Returns 0 with *out containing next tag; or -1 with errno set if error; or
+1 if EOF. */
static int pparse_next(FILE* in, tag_t* out)
{
    int ret = -1;

    tag_init(out);
    char c;

    assert(in);

    /* Read tag name. */
    int i = 0;
    for( i=0;; ++i) {
        c = getc(in);
        if (c == EOF) {
            if (i == 0 && feof(in)) ret = +1;   /* legimate EOF. */
            goto end;
        }
        if (c == '>' || c == ' ')  break;
        if (str_catc(&out->name, c)) goto end;
    }
    if (c == ' ') {

        /* Read attributes. */
        for(;;) {

            /* Read attribute name. */
            char* attribute_name = NULL;
            for(;;) {
                c = getc(in);
                if (c == EOF) goto end;
                if (c == '=' || c == '>' || c == ' ') break;
                if (str_catc(&attribute_name, c)) goto end;
            }
            if (c == '>') break;

            char* attribute_value = NULL;
            if (c == '=') {
                /* Read attribute value. */
                int quote_single = 0;
                int quote_double = 0;
                for(;;) {
                    c = getc(in);
                    if (c == '\'')      quote_single = !quote_single;
                    else if (c == '"')  quote_double = !quote_double;
                    else if (!quote_single && !quote_double
                            && (c == ' ' || c == '/' || c == '>')
                            ) {
                        /* We are at end of attribute value. */
                        break;
                    }
                    else if (c == '\\') {
                        // Escape next character.
                        c = getc(in);
                        if (c == EOF) goto end;
                    }
                    str_catc(&attribute_value, c);
                }

                /* Remove any enclosing quotes. */
                int l = strlen(attribute_value);
                if (l >= 2) {
                    if (
                            (attribute_value[0] == '"' && attribute_value[l-1] == '"')
                            ||
                            (attribute_value[0] == '\'' && attribute_value[l-1] == '\'')
                            ) {
                        memmove(attribute_value, attribute_value+1, l-2);
                        attribute_value[l-2] = 0;
                    }
                }
            }

            tag_attributes_append(out, attribute_name, attribute_value);
            if (c == '/') c = getc(in);
            if (c == '>') break;
        }
    }

    /* Read plain text until next '<'. */
    for(;;) {
        c = getc(in);
        if (c == '<' || feof(in)) break;
        if (str_catc(&out->text, c)) goto end;
    }

    if (0) {
        fprintf(stderr, "text: ");
        for (const char* c = out->text; *c; ++c) {
            if (*c == '\n') fputs("\\n", stderr);
            else putc(*c, stderr);
        }
        putc('\n', stderr);
    }

    ret = 0;

    end:

    if (ret) {
        tag_free(out);
    }
    return ret;
}

static int s_read_matrix(const char* text, fz_matrix* matrix)
{
    int n = sscanf(text,
            "%f %f %f %f %f %f",
            &matrix->a,
            &matrix->b,
            &matrix->c,
            &matrix->d,
            &matrix->e,
            &matrix->f
            );
    assert(n == 6);
    return 0;
}



/* Reads from intermediate .xml file containing spans, into a new
fz_stext_device, which is returned.

(Wec use code directly #included from ../fitz/stext-device.c above). */
static fz_stext_device* spans_to_stext_device(fz_context* ctx, const char* path)
{
    fz_stext_page* page = fz_new_stext_page(ctx, fz_infinite_rect);
    fz_stext_device* dev = (void*) fz_new_stext_device(ctx, page, NULL /*options*/);

    FILE* in = pparse_init(path);
    if (!in) {
        fprintf(stderr, "Failed to open path='%s', errno=%i\n", path, errno);
    }
    assert(in);
    int     e;
    tag_t   tag;
    tag_init(&tag);

    for(;;) {
        e = pparse_next(in, &tag);
        if (e) break;

        /* We essentially ignore <page> tags - not really relevant for creating
        logical runs of text etc. */
        assert(!strcmp(tag.name, "page"));

        for(;;) {
            tag_reset(&tag);
            e = pparse_next(in, &tag);
            assert(!e);
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            //printf("tag.name=%s\n", tag.name);
            assert(!strcmp(tag.name, "span"));
            fz_matrix   ctm;
            fz_matrix   trm;
            s_read_matrix(tag_attributes_find(&tag, "ctm"), &ctm);
            s_read_matrix(tag_attributes_find(&tag, "trm"), &trm);
            const char* font_name = tag_attributes_find(&tag, "font_name");
            const char* f = strchr(font_name, '+');
            if (f)  font_name = f + 1;
            int is_bold = tag_attributes_find_int(&tag, "is_bold", 0);
            int is_italic = tag_attributes_find_int(&tag, "is_italic", 0);
            char* font_name2 = strdup(font_name);
            //if (is_bold) str_cat(&font_name2, "-Bold");
            //if (is_italic) str_cat(&font_name2, "-Oblique");

            //fz_font* font = fz_new_builtin_font(ctx, font_name, is_bold, is_italic);
            fz_font* font = malloc(sizeof(*font));
            bzero(font, sizeof(*font));
            snprintf(font->name, sizeof(font->name), "%s", font_name2);
            free(font_name2);

            int wmode = atoi(tag_attributes_find(&tag, "wmode"));

            #if 0
            if (0) fprintf(stderr, "%s:%i: trm={%f %f %f %f %f %f} ctm={%f %f %f %f %f %f} trm2={%f %f %f %f %f %f}\n",
                    __FILE__, __LINE__,
                    trm.a,
                    trm.b,
                    trm.c,
                    trm.d,
                    trm.e,
                    trm.f,
                    ctm.a,
                    ctm.b,
                    ctm.c,
                    ctm.d,
                    ctm.e,
                    ctm.f,
                    trm2.a,
                    trm2.b,
                    trm2.c,
                    trm2.d,
                    trm2.e,
                    trm2.f
                    );
            #endif

            for(;;) {
                tag_reset(&tag);
                e = pparse_next(in, &tag);
                assert(!e);
                //printf("tag.name=%s\n", tag.name);
                if (!strcmp(tag.name, "/span")) {
                    break;
                }
                assert(!strcmp(tag.name, "span_item"));
                float x     = atof(tag_attributes_find(&tag, "x"));
                float y     = atof(tag_attributes_find(&tag, "y"));
                int gid     = atoi(tag_attributes_find(&tag, "gid"));
                int ucs     = atoi(tag_attributes_find(&tag, "ucs"));
                float adv   = tag_attributes_find_float(&tag, "adv");

                fz_matrix trm2 = trm;
                trm2.e = x;
                trm2.f = y;
                trm2 = fz_concat(trm2, ctm);

                /* This is a hack to prevent fz_add_stext_char() eventually
                getting SEGV in fz_font_ascender(). */
                static fz_buffer*   t3procs[256];
                font->t3procs = t3procs;

                fz_add_stext_char(ctx, dev, font, ucs, gid, trm2, adv, wmode);
            }
        }
    }

    fclose(in);
    return dev;
}

/* Like fprintf() but returns quietly if <out> is NULL. */
static int safe_fprintf(FILE* out, const char* format, ...)
{
    if ( !out)  return 0;
    va_list va;
    va_start(va, format);
    int ret = vfprintf(out, format, va);
    va_end(va);
    return ret;
}

/* Detailed XML dump of the entire structured text data */

void
page_to_xml(fz_context* ctx, fz_stext_page *page, int id, FILE* out_xml)
{
    fz_stext_block *block;
    fz_stext_line *line;
    fz_stext_char *ch;

    safe_fprintf(out_xml, "<page id=\"page%d\" width=\"%g\" height=\"%g\">\n", id,
        page->mediabox.x1 - page->mediabox.x0,
        page->mediabox.y1 - page->mediabox.y0);

    for (block = page->first_block; block; block = block->next)
    {
        switch (block->type)
        {
        case FZ_STEXT_BLOCK_TEXT:
            safe_fprintf(out_xml, "<block bbox=\"%g %g %g %g\">\n",
                    block->bbox.x0, block->bbox.y0, block->bbox.x1, block->bbox.y1);
            for (line = block->u.t.first_line; line; line = line->next)
            {
                fz_font *font = NULL;
                float size = 0;
                const char *name = NULL;

                safe_fprintf(out_xml, "<line bbox=\"%g %g %g %g\" wmode=\"%d\" dir=\"%g %g\">\n",
                        line->bbox.x0, line->bbox.y0, line->bbox.x1, line->bbox.y1,
                        line->wmode,
                        line->dir.x, line->dir.y);

                for (ch = line->first_char; ch; ch = ch->next)
                {
                    if (ch->font != font || ch->size != size)
                    {
                        if (font)
                            safe_fprintf(out_xml, "</font>\n");
                        font = ch->font;
                        size = ch->size;
                        safe_fprintf(out_xml, "<font name=\"%s\" size=\"%g\">\n", font->name, size);
                    }
                    safe_fprintf(out_xml, "<char quad=\"%g %g %g %g %g %g %g %g\" x=\"%f\" y=\"%g\" color=\"#%06x\" c=\"",
                            ch->quad.ul.x, ch->quad.ul.y,
                            ch->quad.ur.x, ch->quad.ur.y,
                            ch->quad.ll.x, ch->quad.ll.y,
                            ch->quad.lr.x, ch->quad.lr.y,
                            ch->origin.x, ch->origin.y,
                            ch->color);
                    switch (ch->c)
                    {
                    case '<': safe_fprintf(out_xml, "&lt;"); break;
                    case '>': safe_fprintf(out_xml, "&gt;"); break;
                    case '&': safe_fprintf(out_xml, "&amp;"); break;
                    case '"': safe_fprintf(out_xml, "&quot;"); break;
                    case '\'': safe_fprintf(out_xml, "&apos;"); break;
                    default:
                           if (ch->c >= 32 && ch->c <= 127)
                               safe_fprintf(out_xml, "%c", ch->c);
                           else
                               safe_fprintf(out_xml, "&#x%x;", ch->c);
                           break;
                    }
                    safe_fprintf(out_xml, "\"/>\n");
                }

                if (font)
                    safe_fprintf(out_xml, "</font>\n");

                safe_fprintf(out_xml, "</line>\n");
            }
            safe_fprintf(out_xml, "</block>\n");
            break;

        case FZ_STEXT_BLOCK_IMAGE:
            safe_fprintf(out_xml, "<image bbox=\"%g %g %g %g\" />\n",
                    block->bbox.x0, block->bbox.y0, block->bbox.x1, block->bbox.y1);
            break;
        }
    }
    safe_fprintf(out_xml, "</page>\n");
}












/* These docx_*() functions generate docx content. Caller must call things
in a sensible order - e.g. don't call docx_paragraph_start() twice without
intervening call to docx_paragraph_finish(). */

static int docx_paragraph_start(char** content)
{
    return str_cat(content, "\n\n<w:p>");
}

static int docx_paragraph_finish(char** content)
{
    return str_cat(content, "\n</w:p>");
}

/* Starts a new run. Caller must ensure that docx_run_finish() was called to
terminate any previous run. */
static int docx_run_start(char** content, const char* font_name, double font_size,
        int bold, int italic)
{
    int e = 0;
    if (!e) e = str_cat(content, "\n<w:r><w:rPr><w:rFonts w:ascii=\"");
    if (!e) e = str_cat(content, font_name);
    if (!e) e = str_cat(content, "\" w:hAnsi=\"");
    if (!e) e = str_cat(content, font_name);
    if (!e) e = str_cat(content, "\"/>");
    if (!e && bold) e = str_cat(content, "<w:b/>");
    if (!e && italic) e = str_cat(content, "<w:i/>");
    if (!e) {
        char    font_size_text[32];
        snprintf(font_size_text, sizeof(font_size_text), "%.1f", font_size * 2);
        e = str_cat(content, font_size_text);
    }
    if (!e) e = str_cat(content, "\"/></w:rPr><w:t xml:space=\"preserve\">");
    assert(!e);
    return e;

}
static int docx_run_finish(char** content)
{
    return str_cat(content, "</w:t></w:r>");
}

static int docx_char_append_string(char** content, char* text)
{
    return str_cat(content, text);
}

static int docx_char_append_char(char** content, char c)
{
    return str_catc(content, c);
}

/* Removes last <len> chars. */
static int docx_char_truncate(char** content, int len)
{
    int content_len = strlen(*content);
    assert(len <= content_len);
    (*content)[content_len - len] = 0;
    return 0;
}

/* Removes last char if it is <c>. */
static int docx_char_truncate_if(char** content, char c)
{
    if (!*content) return 0;
    int l = strlen(*content);
    if (l && (*content)[l-1] == c) {
        (*content)[l-1] = 0;
    }
    return 0;
}


/* Creates docx content from fz_stext_page, applying some heuristics to clean
up the output, and makes *content point to zero-terminated text allocated by
realloc(). */
int
page_to_docx_content(fz_context* ctx, fz_stext_page *page, char** content)
{
    *content = NULL;

    fz_stext_block* block;
    for (block = page->first_block; block; block = block->next)
    {
        if (block->type == FZ_STEXT_BLOCK_TEXT) {

            docx_paragraph_start(content);

            fz_stext_char *ch_prev = NULL;
            fz_font *font = NULL;
            float font_size = 0;

            fz_stext_line* line;
            for (line = block->u.t.first_line; line; line = line->next)
            {
                /* If previous line did not end with hyphen, append a space. */
                if (ch_prev && ch_prev->c != '-') {
                    docx_char_append_char(content, ' ');
                }

                fz_stext_char *ch;
                for (ch = line->first_char; ch; ch = ch->next)
                {
                    if (ch->font != font || ch->size != font_size)
                    {
                        if (font) {
                            docx_run_finish(content);
                            font = NULL;
                            font_size = 0;
                        }

                        font = ch->font;
                        font_size = ch->size;
                        int bold = strstr(font->name, "-Bold") ? 1 : 0;
                        int italic = strstr(font->name, "-Oblique") ? 1 : 0;

                        docx_run_start(content, font->name, font_size, bold, italic);
                        ch_prev = NULL; /* Need to avoid removing prev space. */
                    }

                    /* Discard spaces which overlap with the following
                    character - these sometimes seem to appear in the
                    middle of words. */
                    if (ch_prev && ch_prev->c == ' ') {
                        /* We get slight rounding errors, so sometimes the
                        normal behaviour where quads are adjacent ends up with
                        them slightly overlapping, so we use a small correction
                        to avoid spurious removal of legitimate spaces. */
                        if (ch_prev->quad.ur.x - 0.001 > ch->quad.ul.x) {
                            size_t l = strlen(*content);
                            const char* tail = *content;
                            if (l > 20) {
                                tail = (*content) + l - 20;
                            }
                            if (0) fprintf(stderr, "removing space:\n"
                                    "    ch_prev->quad=(ul=(%f, %f) ur=(%f, %f) ll==(%f, %f) lr==(%f, %f)\n"
                                    "         ch->quad=(ul=(%f, %f) ur=(%f, %f) ll==(%f, %f) lr==(%f, %f)\n"
                                    "    ch->c=%c\n"
                                    "    tail='%s'\n"
                                    ,
                                    ch_prev->quad.ul.x,
                                    ch_prev->quad.ul.y,
                                    ch_prev->quad.ur.x,
                                    ch_prev->quad.ur.y,
                                    ch_prev->quad.ll.x,
                                    ch_prev->quad.ll.y,
                                    ch_prev->quad.lr.x,
                                    ch_prev->quad.lr.y,
                                    ch->quad.ul.x,
                                    ch->quad.ul.y,
                                    ch->quad.ur.x,
                                    ch->quad.ur.y,
                                    ch->quad.ll.x,
                                    ch->quad.ll.y,
                                    ch->quad.lr.x,
                                    ch->quad.lr.y,
                                    ch->c,
                                    tail
                                    );

                            docx_char_truncate(content, 1);
                        }
                    }

                    if (0) {}
                    else if (ch->c == '<')  docx_char_append_string(content, "&lt;");
                    else if (ch->c == '>')  docx_char_append_string(content, "&gt;");
                    else if (ch->c == '&')  docx_char_append_string(content, "&amp;");
                    else if (ch->c == '"')  docx_char_append_string(content, "&quot;");
                    else if (ch->c == '\'') docx_char_append_string(content, "&apos;");
                    else if (ch->c >= 32 && ch->c <= 127) docx_char_append_char(content, ch->c);
                    else {
                        char    buffer[32];
                        snprintf(buffer, sizeof(buffer), "&#x%x;", ch->c);
                        docx_char_append_string(content, buffer);
                    }

                    ch_prev = ch;
                }
                /* Remove any trailing '-' at end of line. */
                docx_char_truncate_if(content, '-');
            }

            if (font) {
                docx_run_finish(content);
                font = NULL;
            }
            docx_paragraph_finish(content);
        }
    }
    return 0;
}



static int systemf(const char* format, ...)
{
    char* command;
    va_list va;
    va_start(va, format);
    int e = vasprintf(&command, format, va);
    va_end(va);
    if (e < 0) return e;
    fprintf(stderr, "running: %s\n", command);
    e = system(command);
    free(command);
    return e;
}

/*
Creates a .docx file based on a template, by inserting <content> into
word/document.xml.

content:
    E.g. from process().
path_out:
    Name of .docx file to create. Must not contain single-quote character.
path_template:
    Name of .docx file to use as a template.
preserve_dir:
    If true, we don't delete the temporary directory <path_out>.dir containing
    unzipped .docx content.

Returns 0 on success or -1 with errno set.

We use the 'zip' and 'unzip' commands.
*/
static int create_docx(const char* content, const char* path_out, const char* path_template, int preserve_dir)
{
    assert(content);
    assert(path_out);
    assert(path_template);

    /* This gets set to zero only if everything succeeds. */
    int ret = -1;

    char*   path_tempdir = NULL;
    char*   word_document_xml = NULL;
    char*   original = NULL;
    FILE*   f = NULL;

    int e;

    if (strchr(path_out, '\'')) {
        fprintf(stderr, "path_out contains single-quote character: %s\n", path_out);
        errno = EINVAL;
        goto end;
    }

    if (asprintf(&path_tempdir, "%s.dir", path_out) < 0) goto end;
    if (systemf("rm -r '%s' 2>/dev/null", path_tempdir) < 0) goto end;

    if (mkdir(path_tempdir, 0777)) {
        fprintf(stderr, "%s:%i: Failed to create directory: %s\n",
                __FILE__, __LINE__, path_tempdir);
        goto end;
    }

    if (0) fprintf(stderr, "Unzipping template document '%s' to tempdir: %s\n", path_template, path_tempdir);
    if (systemf("unzip -q -d %s %s", path_tempdir, path_template)) {
        fprintf(stderr, "%s:%i: Failed to unzip %s into %s\n",
                __FILE__, __LINE__, path_template, path_tempdir);
        goto end;
    }

    if (asprintf(&word_document_xml, "%s/word/document.xml", path_tempdir) < 0) goto end;

    if (0) fprintf(stderr, "Reading tempdir's word/document.xml object\n");
    f = fopen(word_document_xml, "r");
    if (!f) {
        fprintf(stderr, "%s:%i: Failed to open docx object: %s\n",
                __FILE__, __LINE__, word_document_xml);
        goto end;
    }
    original = read_all(f);
    if (!original) goto end;
    if (fclose(f) < 0) goto end;
    f = NULL;

    const char* original_marker = "<w:body>";
    const char* original_pos = strstr(original, original_marker);
    if (!original_pos) {
        fprintf(stderr, "%s:%i: error: could not find '%s' in docx object: %s\n",
                __FILE__, __LINE__, original_marker, word_document_xml);
        errno = ESRCH;
        goto end;
    }
    original_pos += strlen(original_marker);

    if (0) fprintf(stderr, "Writing tempdir's word/document.xml file\n");
    f = fopen(word_document_xml, "w");
    if (!f) {
        fprintf(stderr, "%s:%i: error: Failed to open .docx for writing: %s",
                __FILE__, __LINE__, word_document_xml);
        goto end;
    }
    if (0
            || fwrite(original, original_pos - original, 1 /*nmemb*/, f) < 0
            || fwrite(content, strlen(content), 1 /*nmemb*/, f) < 0
            || fwrite(original_pos, strlen(original_pos), 1 /*nmemb*/, f) < 0
            || fclose(f) < 0
            ) {
        fprintf(stderr, "%s:%i: error: Failed to write to: %s",
                __FILE__, __LINE__, word_document_xml);
        goto end;
    }
    f = NULL;

    if (0) fprintf(stderr, "Zipping tempdir to create create %s\n", path_out);
    const char* path_out_leaf = strrchr(path_out, '/');
    if (!path_out_leaf) path_out_leaf = path_out;
    e = systemf("cd %s && zip -q -r ../%s .", path_tempdir, path_out_leaf);
    if (e) {
        fprintf(stderr, "%s:%i: error: Zip command failed to convert '%s' directory into output file: %s",
                __FILE__, __LINE__, path_tempdir, path_out);
        if (e > 0) errno = EIO;
        goto end;
    }

    if (!preserve_dir) {
        e = systemf("rm -r '%s'", path_tempdir);
        if (e) {
            fprintf(stderr, "%s:%i: error: Failed to delete tempdir: %s",
                    __FILE__, __LINE__, path_tempdir);
            if (e > 0) errno = EIO;
            goto end;
        }
    }

    ret = 0;

    end:
    if (path_tempdir)   free(path_tempdir);
    if (word_document_xml)  free(word_document_xml);
    if (original)   free(original);
    if (f)  fclose(f);

    return ret;
}



/* Things for direct conversion of text spans into lines and paragraphs,
without using mupdf's stext device. */

typedef struct
{
    float   x;
    float   y;
    int     gid;
    int     ucs;
    float   adv;
} span_item_t;

typedef struct span_t
{
    fz_matrix   ctm;
    fz_matrix   trm;
    const char* font_name;
    // font size is fz_matrix_expansion(trm).
    int         font_bold;
    int         font_italic;
    int         wmode;
    int             items_num;
    span_item_t*    items;
} span_t;

static void span_append_c(span_t* span, int c)
{
    span_item_t* items = realloc(span->items, sizeof(*items) * (span->items_num + 1));
    assert(items);
    span->items = items;
    bzero(&span->items[span->items_num], sizeof(span_item_t));
    span->items[span->items_num].ucs = c;
    span->items_num += 1;
}

static span_t** g_spans = NULL;
static int      g_spans_num = 0;

static int spans_append(span_t* span)
{
    span_t** spans = realloc(g_spans, sizeof(*spans) * (g_spans_num+1));
    if (!spans) return 1;
    g_spans = spans;
    g_spans[g_spans_num] = span;
    g_spans_num += 1;
    return 0;
}

static double spans_adv(span_t* a_span, span_item_t* a, span_item_t* b)
{
    double delta_x = b->x - a->x;
    double delta_y = b->y - a->y;
    double s = sqrt( delta_x*delta_x + delta_y*delta_y);
    double a_size = a->adv * fz_matrix_expansion(a_span->trm);
    s -= a_size;
    return s;
}

static span_item_t* span_item_first(span_t* span)
{
    assert(span->items_num);
    return &span->items[0];
}

static span_item_t* span_item_last(span_t* span)
{
    assert(span->items_num);
    return &span->items[span->items_num-1];
}

static void span_dump(span_t* span, FILE* out)
{
    fprintf(out, "(%f,%f)..(%f,%f) '",
            span_item_first(span)->x,
            span_item_first(span)->y,
            span_item_last(span)->x,
            span_item_last(span)->y
            );
    int i;
    for(i=0; i<span->items_num; ++i) {
        fprintf(out, "%c", span->items[i].ucs);
    }
    fprintf(out, "'");
}


static double span_angle(span_t* span)
{
    /* Not sure whether this is right. Inclined text seems to be done by
    setting the ctm matrix, so not really sure what trm matrix does. This code
    assumes that it also inclines text, but maybe it only rotates individual
    glyphs? */
    if (span->wmode == 0) {
        return atan2(span->trm.b, span->trm.a);
    }
    else {
        return atan2(span->trm.d, span->trm.c);
    }
}

double span_adv_total(span_t* span)
{
    double dx = span_item_last(span)->x - span_item_first(span)->x;
    double dy = span_item_last(span)->y - span_item_first(span)->y;
    /* We add on the advance of the last item; this avoids us returning zero if
    there's only one item. */
    double adv = span_item_last(span)->adv * fz_matrix_expansion(span->trm);
    return sqrt(dx*dx + dy*dy) + adv;
}

/* List of spans that are aligned on same line. */
typedef struct
{
    span_t**    spans;
    int         spans_num;
} line_t;

/* Returns first span in a line. */
span_t* line_span_last(line_t* line)
{
    return line->spans[line->spans_num - 1];
}

/* Returns list span in a line. */
span_t* line_span_first(line_t* line)
{
    return line->spans[0];
}

/* Returns first span_item in a line. */
static span_item_t* line_item_first(line_t* line)
{
    span_t* span = line_span_first(line);
    return span_item_first(span);
}

/* Returns last span_item in a line. */
static span_item_t* line_item_last(line_t* line)
{
    span_t* span = line_span_last(line);
    return span_item_last(span);
}

/* Returns angle of <line>. */
static double line_angle(line_t* line)
{
    /* All spans in a line must have same angle, so just use the first span. */
    assert(line->spans_num > 0);
    return span_angle(line->spans[0]);
}

/* Returns 1 if lines have same wmode and are at the same angle, else 0. */
static int lines_are_compatible(line_t* a, line_t* b, double angle_a)
{
    if (a == b) return 0;
    if (!a->spans || !b->spans) return 0;
    if (line_span_first(a)->wmode != line_span_first(b)->wmode)   return 0;
    if (memcmp(
            &line_span_first(a)->ctm,
            &line_span_first(b)->ctm,
            sizeof(fz_matrix)
            )) {
        return 0;
    }
    double angle_b = span_angle(line_span_first(b));
    if (angle_b != angle_a) return 0;
    return 1;
}

/* Creates representation of span_t's that consists of a list of line_t's.

We only join spans that are at the same angle and are aligned.

On entry:
    Original value of *o_lines and *o_lines_num are ignored.

    <spans> points to array of <spans_num> span_t*'s, each pointing to a
    span_t.

On exit:
    If we succeed, we return 0, with *o_lines pointing to array of *o_lines_num
    line_t*'s, each pointing to a line_t.

    Otherwise we return -1 with errno set. *o_lines and *o_lines_num are
    undefined.
*/
static int make_lines(span_t** spans, int spans_num, line_t*** o_lines, int* o_lines_num)
{
    int ret = -1;

    /* Make a line_t for each span. Then we will join some of these line_t's
    together before returning. */
    int     lines_num = spans_num;
    line_t** lines = NULL;

    lines = malloc(sizeof(*lines) * lines_num);
    if (!lines) goto end;

    int a;
    /* Ensure we can clean up after error. */
    for (a=0; a<lines_num; ++a) {
        lines[a] = NULL;
    }
    for (a=0; a<lines_num; ++a) {
        lines[a] = malloc(sizeof(line_t));
        if (!lines[a])  goto end;
        lines[a]->spans_num = 0;
        lines[a]->spans = malloc(sizeof(span_t*) * 1);
        if (!lines[a]->spans)   goto end;
        lines[a]->spans_num = 1;
        lines[a]->spans[0] = spans[a];
    }

    /* For each line, look for nearest aligned line, and append if found. */
    int num_joins = 0;
    for (a=0; a<lines_num; ++a) {

        line_t* line_a = lines[a];
        if (!line_a->spans) {
            /* This line is empty - already been appended to a different line. */
            continue;
        }

        line_t* nearest_line = NULL;
        int nearest_line_b = -1;
        double nearest_adv = 0;

        span_t* span_a = line_span_last(line_a);
        double angle_a = span_angle(span_a);

        int b;
        for (b=0; b<lines_num; ++b) {

            line_t* line_b = lines[b];
            if (!lines_are_compatible(line_a, line_b, angle_a)) {
                continue;
            }

            /* Find angle between last glyph of span_a and first glyph of
            span_b. This detects whether the lines are lined up with each other
            (as opposed to being at the same angle but in different lines). */
            span_t* span_b = line_span_first(line_b);
            double angle_a_b = atan2(
                    span_item_first(span_b)->y - span_item_last(span_a)->y,
                    span_item_first(span_b)->x - span_item_last(span_a)->x
                    );
            /* Might want to relax this when we test on non-horizontal lines.
            */
            const double    angle_tolerance_deg = 1;
            if (fabs(angle_a_b - angle_a) * 180/3.14 <= angle_tolerance_deg) {
                /* Find distance between end of line_a and beginning of line_b. */
                double adv = spans_adv(span_a, span_item_last(span_a), span_item_first(span_b));
                if (!nearest_line || adv < nearest_adv) {
                    nearest_line = line_b;
                    nearest_adv = adv;
                    nearest_line_b = b;
                }
            }
        }

        if (nearest_line) {

            /* line_a and nearest_line are aligned so we can move line_b's spans on
            to the end of line_a. */

            span_t* span_b = line_span_first(nearest_line);

            if (1
                    && span_item_last(span_a)->ucs != ' '
                    && span_item_first(span_b)->ucs != ' '
                    ) {
                /* Find average advance of the two adjacent spans in the two
                lines we are considering joining, so that we can decide whether
                the distance between them is large enough to merit joining with
                a space character). */
                double average_adv = (
                        (span_adv_total(span_a) + span_adv_total(span_b))
                        /
                        (span_a->items_num + span_b->items_num)
                        );

                int insert_space = (nearest_adv > 0.25 * average_adv);
                if (insert_space) {
                    /* Append space to span_a before concatenation. */
                    if (0) fprintf(stderr, "(inserted space)\n");
                    span_item_t* p = realloc(span_a->items, (span_a->items_num + 1) * sizeof(span_item_t));
                    if (!p) goto end;
                    span_a->items = p;
                    span_item_t* item = &span_a->items[span_a->items_num];
                    span_a->items_num += 1;
                    bzero(item, sizeof(*item));
                    item->ucs = ' ';
                    item->adv = nearest_adv;
                }

                if (0) {
                    /* Show details about what we're joining. */
                    fprintf(stderr,
                            "joining line insert_space=%i a=%i (y=%f) to line nearest_line_b=%i (y=%f). nearest_adv=%lf average_adv=%lf\n",
                            insert_space,
                            a,
                            span_item_last(span_a)->y,
                            nearest_line_b,
                            span_item_first(span_b)->y,
                            nearest_adv,
                            average_adv
                            );
                    fprintf(stderr, "a: ");
                    span_dump(span_a, stderr);
                    fprintf(stderr, "\nb: ");
                    span_dump(span_b, stderr);
                    fprintf(stderr, "\n");
                }
            }

            /* We might end up with two adjacent spaces here. But removing a
            space could result in an empty line_t, which could break various
            assumptions elsewhere. */

            span_t** s = realloc(
                    line_a->spans,
                    sizeof(span_t*) * (line_a->spans_num + nearest_line->spans_num)
                    );
            if (!s) goto end;
            line_a->spans = s;
            int k;
            for (k=0; k<nearest_line->spans_num; ++k) {
                line_a->spans[ line_a->spans_num + k] = nearest_line->spans[k];
            }
            line_a->spans_num += nearest_line->spans_num;

            /* Ensure that we ignore nearest_line from now on. */
            free(nearest_line->spans);
            nearest_line->spans = NULL;
            nearest_line->spans_num = 0;

            num_joins += 1;

            if (nearest_line_b > a) {
                /* We haven't yet tried appending any spans to nearest_line, so
                the new extended line_a needs checking again. */
                a -= 1;
            }
        }
    }

    if (0) fprintf(stderr, "Have made %i joins out of %i spans\n", num_joins, lines_num);

    /* Remove empty lines left behind after we appended pairs of lines. */
    int from;
    int to;
    for (from=0, to=0; from<lines_num; ++from) {
        if (lines[from]->spans) {
            lines[to] = lines[from];
            to += 1;
        }
    }
    lines_num = to;
    line_t** l = realloc(lines, sizeof(line_t*) * lines_num);
    assert(l); /* Should always succeed because we're not increasing allocation size. */
    lines = l;

    *o_lines = lines;
    *o_lines_num = lines_num;
    ret = 0;

    end:
    if (ret) {
        /* Free everything. */
        for (a=0; a<lines_num; ++a) {
            if (lines[a])   free(lines[a]->spans);
            free(lines[a]);
        }
    }
    return ret;
}


/* A list of lines that are aligned and adjacent to each other so as to form a
paragraph. */
typedef struct
{
    line_t**    lines;
    int         lines_num;
} para_t;

/* Returns first line in paragraph. */
line_t* para_line_first(const para_t* para)
{
    assert(para->lines_num);
    return para->lines[0];
}

/* Returns last line in paragraph. */
line_t* para_line_last(const para_t* para)
{
    assert(para->lines_num);
    return para->lines[ para->lines_num-1];
}

/* Returns max font size of all span_t's in a line_t. */
double line_font_size_max(line_t* line)
{
    double  size_max = 0;
    int i;
    for (i=0; i<line->spans_num; ++i) {
        span_t* span = line->spans[i];
        int size = fz_matrix_expansion(span->trm);
        if (size > size_max) {
            size_max = size;
        }
    }
    return size_max;
}



/* Find distance between line_a and line_b. */
/*
        _-R
     _-
    A------------_P
     \        _-
      \    _B
       \_-
        Q

AR and QBP are parallel, and are the lines of text a and b
respectively.

AQB is a right angle.
APB and PAR are both angle_a.

We need to find AQ.
*/
static double line_distance(double ax, double ay, double bx, double by, double angle)
{
    double dx = bx - ax;
    double dy = by - ay;
    double angle1 = atan2(-dy, dx); /* angle BAP */
    double angle2 = angle + angle1; /* angle BAR = ABQ */
    double distance1 = sqrt(dx*dx + dy*dy); /* AB */
    double distance = distance1 * sin(angle2); /* AQ */
    if (angle == 0) {
        /* Sanity check if AR and QBP are horizontal. */
        assert(fabs(distance - (ay - by)) < 0.1);
    }
    return distance;
}

/* A comparison function for use with qsort(), for sorting paragraphs within a
page. */
static int paras_cmp(const void* a, const void* b)
{
    para_t* const* a_para = a;
    para_t* const* b_para = b;
    line_t* a_line = para_line_first(*a_para);
    line_t* b_line = para_line_first(*b_para);

    span_t* a_span = line_span_first(a_line);
    span_t* b_span = line_span_first(b_line);

    /* If ctm matrices differ, always return this diff first. */
    int d = memcmp(&a_span->ctm, &b_span->ctm, sizeof(a_span->ctm));
    if (d)  return d;

    double a_angle = line_angle(a_line);
    double b_angle = line_angle(b_line);
    if (fabs(a_angle - b_angle) > 3.14/2) {
        /* Give up if more than 90 deg. */
        return 0;
    }
    double angle = (a_angle + b_angle) / 2;
    double ax = line_item_first(a_line)->x;
    double ay = line_item_first(a_line)->y;
    double bx = line_item_first(b_line)->x;
    double by = line_item_first(b_line)->y;
    double distance = line_distance(ax, ay, bx, by, angle);
    if (distance > 0)   return -1;
    if (distance < 0)   return +1;
    return 0;
}

/* Creates a representation of line_t's that consists of a list of para_t's.

We only join lines that are at the same angle and are adjacent.

On entry:
    Original value of *o_paras and *o_paras_num are ignored.

    <lines> points to array of <lines_num> line_t*'s, each pointing to a
    line_t.

On exit:
    On sucess, returns zero with *o_paras points to array of *o_paras_num
    para_t*'s, each pointing to a para_t. In the array, para_t's with same
    angle are sorted.

    On failure, returns -1 with errno set. *o_paras and *o_paras_num are
    undefined.
*/
static int make_paras(line_t** lines, int lines_num, para_t*** o_paras, int* o_paras_num)
{
    int ret = -1;
    para_t** paras = NULL;

    int paras_num = lines_num;
    paras = malloc(sizeof(*paras) * paras_num);
    if (!paras) goto end;

    int a;
    /* Ensure we can clean up after error. */
    for (a=0; a<paras_num; ++a) {
        paras[a] = NULL;
    }
    for (a=0; a<paras_num; ++a) {
        paras[a] = malloc(sizeof(para_t));
        if (!paras[a]) goto end;
        paras[a]->lines_num = 0;
        paras[a]->lines = malloc(sizeof(line_t*) * 1);
        if (!paras[a]->lines) goto end;
        paras[a]->lines_num = 1;
        paras[a]->lines[0] = lines[a];
    }

    int num_joins = 0;
    for (a=0; a<paras_num; ++a) {

        para_t* para_a = paras[a];
        if (!para_a->lines) {
            /* This para is empty - already been appended to a different para. */
            continue;
        }

        para_t* nearest_para = NULL;
        int nearest_para_b = -1;
        double nearest_para_distance = -1;
        assert(para_a->lines_num > 0);

        line_t* line_a = para_line_last(para_a);
        double angle_a = line_angle(line_a);

        /* Look for nearest run that could be appended to run_a. */
        int b;
        for (b=0; b<paras_num; ++b) {
            para_t* para_b = paras[b];
            if (!para_b->lines) {
                /* This para is empty - already been appended to a different
                para. */
                continue;
            }
            line_t* line_b = para_line_first(para_b);
            if (!lines_are_compatible(line_a, line_b, angle_a)) {
                continue;
            }

            double ax = line_item_last(line_a)->x;
            double ay = line_item_last(line_a)->y;
            double bx = line_item_first(line_b)->x;
            double by = line_item_first(line_b)->y;
            double distance = line_distance(ax, ay, bx, by, angle_a);

            if (distance > 0) {
                if (nearest_para_distance == -1 || distance < nearest_para_distance) {
                    nearest_para_distance = distance;
                    nearest_para_b = b;
                    nearest_para = para_b;
                }
            }
        }

        if (nearest_para) {
            line_t* line_b = para_line_first(nearest_para);
            double line_b_size = line_font_size_max(para_line_first(nearest_para));
            if (0) fprintf(stderr, "joing paragraphs. a=(%lf,%lf) b=(%lf,%lf) nearest_para_distance=%lf line_b_size=%lf\n",
                    line_item_last(line_a)->x,
                    line_item_last(line_a)->y,
                    line_item_first(line_b)->x,
                    line_item_first(line_b)->y,
                    nearest_para_distance,
                    line_b_size
                    );
            if (nearest_para_distance < 1.5 * line_b_size) {
                /* Join these two para_t's. */
                span_t* a_span = line_span_last(line_a);
                if (span_item_last(a_span)->ucs == '-') {
                    /* remove trailing '-' at end of prev line. */
                    a_span->items_num -= 1;
                }
                else {
                    /* Insert space before joining adjacent lines. */
                    span_append_c(line_span_last(line_a), ' ');
                }

                int a_lines_num_new = para_a->lines_num + nearest_para->lines_num;
                line_t** l = realloc(para_a->lines, sizeof(line_t*) * a_lines_num_new);
                if (!l) goto end;
                para_a->lines = l;
                int i;
                for (i=0; i<nearest_para->lines_num; ++i) {
                    para_a->lines[para_a->lines_num + i] = nearest_para->lines[i];
                }
                para_a->lines_num = a_lines_num_new;

                /* Ensure that we skip nearest_para in future. */
                free(nearest_para->lines);
                nearest_para->lines = NULL;
                nearest_para->lines_num = 0;

                num_joins += 1;
                if (0) fprintf(stderr, "have joined para a=%i to snearest_para_b=%i\n", a, nearest_para_b);

                if (nearest_para_b > a) {
                    /* We haven't yet tried appending any paras to
                    nearest_para_b, so the new extended para_a needs checking
                    again. */
                    a -= 1;
                }
            }
        }
    }

    /* Remove empty paragraphs. */
    int from;
    int to;
    for (from=0, to=0; from<paras_num; ++from) {
        if (paras[from]->lines) {
            paras[to] = paras[from];
            to += 1;
        }
    }
    if (0) fprintf(stderr, "paras_num=%i => %i\n", paras_num, to);
    paras_num = to;
    para_t** p = realloc(paras, sizeof(para_t*) * paras_num);
    assert(p); /* Should always succeed because we're not increasing allocation size. */
    paras = p;

    /* Sort paragraphs. */
    qsort(paras, paras_num, sizeof(para_t*), paras_cmp);

    *o_paras = paras;
    *o_paras_num = paras_num;
    ret = 0;
    if (0) fprintf(stderr, "Have made %i joins out of %i paras\n", num_joins, paras_num);

    end:

    if (ret) {
        for (a=0; a<paras_num; ++a) {
            if (paras[a])   free(paras[a]->lines);
            free(paras[a]);
        }
    }
    return ret;
}



typedef struct
{
    span_t**    spans;
    int         spans_num;

    para_t**    paras;
    int         paras_num;
} page_t;

static int page_span_append(page_t* page, span_t* span)
{
    span_t** s = realloc(page->spans, sizeof(*s) * (page->spans_num + 1));
    if (!s) return -1;
    page->spans = s;
    page->spans[page->spans_num] = span;
    page->spans_num += 1;
    return 0;
}

/* Reads from intermediate data and converts into docx content. On return
*content points to zero-terminated content, allocated by realloc(). */
static int spans_to_docx_content(const char* path, char** content)
{
    int ret = -1;

    *content = NULL;
    FILE* in = NULL;
    page_t**    pages = NULL;
    int         pages_num = 0;

    in = pparse_init(path);
    if (!in) {
        fprintf(stderr, "Failed to open: %s\n", path);
        goto end;
    }

    int e;
    tag_t   tag;
    tag_init(&tag);

    /* Data read from <path> is expected to be XML looking like:

    <page>
        <span>
            <span_item ...>
            <span_item ...>
            ...
        </span>
        <span>
            ...
        </span>
        ...
    </page>
    <page>
        ...
    </page>
    ...

    We convert this into a list of page_t's, each containing a list of
    span_t's, each containing a list of span_element_t's.

    While doing this, we do some within-span processing:
        We remove spurious spaces.
        We split spans in two where there seem to be large gaps.
    */
    for(;;) {
        e = pparse_next(in, &tag);
        if (e) break;

        assert(!strcmp(tag.name, "page"));
        if (0) fprintf(stderr, "loading spans for page %i...\n", pages_num);
        page_t** p = realloc(pages, sizeof(*p) * (pages_num + 1));
        assert(p);
        pages = p;
        pages[pages_num] = malloc(sizeof(page_t));
        assert(pages[pages_num]);
        page_t* page = pages[pages_num];
        page->spans = NULL;
        page->spans_num = 0;
        pages_num += 1;

        for(;;) {
            tag_reset(&tag);
            e = pparse_next(in, &tag);
            assert(!e);
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            //printf("tag.name=%s\n", tag.name);
            assert(!strcmp(tag.name, "span"));

            span_t* span = malloc(sizeof(*span));
            assert(span);
            page_span_append(page, span);

            s_read_matrix(tag_attributes_find(&tag, "ctm"), &span->ctm);
            s_read_matrix(tag_attributes_find(&tag, "trm"), &span->trm);
            span->font_name = tag_attributes_find(&tag, "font_name");
            const char* f = strchr(span->font_name, '+');
            if (f)  span->font_name = f + 1;
            //span->font_bold = tag_attributes_find_int(&tag, "is_bold", 0);
            //span->font_italic = tag_attributes_find_int(&tag, "is_italic", 0);
            span->font_bold = strstr(span->font_name, "-Bold") ? 1 : 0;
            span->font_italic = strstr(span->font_name, "-Oblique") ? 1 : 0;
            span->wmode = atoi(tag_attributes_find(&tag, "wmode"));
            span->items_num = atoi(tag_attributes_find(&tag, "len"));
            span->items = malloc(sizeof(span_item_t) * span->items_num);

            float font_size = fz_matrix_expansion(span->trm);

            fz_point dir;
            if (span->wmode) {
                dir.x = 0;
                dir.y = 1;
            }
            else {
                dir.x = 1;
                dir.y = 0;
            }
            dir = fz_transform_vector(dir, span->trm);

            fz_point pos = {span->trm.e, span->trm.f};

            int i;
            for (i=0; i<span->items_num; ++i) {
                tag_reset(&tag);
                e = pparse_next(in, &tag);
                assert(!e);
                assert(!strcmp(tag.name, "span_item"));
                span_item_t*    span_item = &span->items[i];
                span_item->x    = atof(tag_attributes_find(&tag, "x"));
                span_item->y    = atof(tag_attributes_find(&tag, "y"));
                span_item->gid  = atoi(tag_attributes_find(&tag, "gid"));
                span_item->ucs  = atoi(tag_attributes_find(&tag, "ucs"));
                span_item->adv  = atof(tag_attributes_find(&tag, "adv"));

                if (i == 0) {
                    pos.x = span_item->x;
                    pos.y = span_item->y;
                }

                float err_x = (span_item->x - pos.x) / font_size;
                float err_y = (span_item->y - pos.y) / font_size;
                if (0) fprintf(stderr, "ucs=%c pos=(%f, %f) span_item=(%f, %f) err=(%f, %f) adv=%f\n",
                        span_item->ucs,
                        pos.x, pos.y,
                        span_item->x, span_item->y,
                        err_x, err_y,
                        span_item->adv
                        );

                if (1
                        && i
                        && span->items[i-1].ucs == ' '
                        && err_x < -span_item[-1].adv / 2
                        && err_x > -span_item[-1].adv
                        ) {
                    /* This character overlaps with previous space
                    character. We discard previous space character - these
                    sometimes seem to appear in the middle of words for some
                    reason. */
                    if (0) fprintf(stderr, "removing space\n");
                    span->items[i-1] = span->items[i];
                    i -= 1;
                    span->items_num -= 1;
                }
                else if (fabs(err_x) > 0.01 || fabs(err_y) > 0.01) {
                    /* This character doesn't seem to be a continuation of
                    previous characters, so split into two spans. This often
                    splits text incorrectly, but this is corrected later when
                    we join spans into lines. */
                    if (0) {
                        fprintf(stderr, "Splitting into new span. err=(%f, %f) pos=(%f, %f): ",
                                err_x, err_y,
                                pos.x, pos.y
                                );
                        int j;
                        for (j=i<10; j<i+10; ++j) {
                            if (j < 0) continue;
                            if (j >= span->items_num) break;
                            fprintf(stderr, "%c%c",
                                    (j==i) ? '_' : ' ',
                                    span->items[j].ucs
                                    );
                        }
                        fprintf(stderr, "\n");
                    }
                    span_t* span2 = malloc(sizeof(*span));
                    assert(span2);
                    page_span_append(page, span2);
                    *span2 = *span;
                    span2->items_num = span->items_num - i;
                    span2->items = malloc(sizeof(span_item_t) * span2->items_num);
                    span2->items[0] = *span_item;
                    pos.x = span_item->x;
                    pos.y = span_item->y;

                    span_item = &span2->items[0];

                    span->items_num = i;
                    span = span2;
                    i = 0;
                }

                pos.x += span_item->adv * dir.x;
                pos.y += span_item->adv * dir.y;
            }

            tag_reset(&tag);
            e = pparse_next(in, &tag);
            assert(!e);
            assert(!strcmp(tag.name, "/span"));
        }

        if (0) fprintf(stderr, "page=%i page->num_spans=%i\n", pages_num, page->spans_num);
    }
    fclose(in);

    /* Now for each page we join spans into lines and paragraphs. A line is a
    list of spans that are at the same angle and on the same line. A paragraph
    is a list of lines that are at the same angle and close together. */
    int p;
    for (p=0; p<pages_num; ++p) {
        if (0) fprintf(stderr, "==[page %i]:\n", p);
        page_t* page = pages[p];

        line_t**    lines;
        int         lines_num;
        make_lines(page->spans, page->spans_num, &lines, &lines_num);

        make_paras(lines, lines_num, &page->paras, &page->paras_num);
    }

    /* Write paragraphs into <content>. */
    *content = NULL;
    for (p=0; p<pages_num; ++p) {
        page_t* page = pages[p];

        const char* font_name = NULL;
        float       font_size = 0;
        int         font_bold = 0;
        int         font_italic = 0;
        int p;
        for (p=0; p<page->paras_num; ++p) {
            para_t* para = page->paras[p];
            if (0) fprintf(stderr, "\n[para] ");
            docx_paragraph_start(content);

            int l;
            for (l=0; l<para->lines_num; ++l) {
                line_t* line = para->lines[l];
                if (0) fprintf(stderr, " [line] ");
                int s;
                for (s=0; s<line->spans_num; ++s) {
                    span_t* span = line->spans[s];
                    if (0) {
                        fprintf(stderr, " [span ");
                        if (!font_name || strcmp(span->font_name, font_name)) {
                            fprintf(stderr, "%s", span->font_name);
                        }
                        if (span->font_bold != font_bold || span->font_italic != font_italic) {
                            if (0) fprintf(stderr, " %c%c",
                                    span->font_bold ? 'b':'-',
                                    span->font_italic ? 'i' : '-'
                                    );
                        }
                        fprintf(stderr, "]");
                    }
                    if (!font_name
                            || strcmp(span->font_name, font_name)
                            || fz_matrix_expansion(span->trm) != font_size
                            || span->font_bold != font_bold
                            || span->font_italic != font_italic
                            ) {
                        if (font_name) {
                            docx_run_finish(content);
                            if (0) fprintf(stderr, " [font %s:%lf:%c%c] ",
                                    span->font_name,
                                    fz_matrix_expansion(span->trm),
                                    span->font_bold ? 'b' : '-',
                                    span->font_italic ? 'i' : '-'
                                    );
                        }
                        if (0) fprintf(stderr, " [%s %c%c] ",
                                span->font_name,
                                span->font_bold ? 'b':'-',
                                span->font_italic ? 'i' : '-'
                                );
                        font_name = span->font_name;
                        font_bold = span->font_bold;
                        font_italic = span->font_italic;
                        font_size = fz_matrix_expansion(span->trm);
                        docx_run_start(content, font_name, font_size, font_bold, font_italic);
                    }

                    int si;
                    for (si=0; si<span->items_num; ++si) {
                        span_item_t* span_item = &span->items[si];
                        if (0) fprintf(stderr, "%c", span_item->ucs);
                        if (0) fprintf(stderr, "[span_item] %c (%f, %f)\n",
                                span_item->ucs,
                                span_item->x,
                                span_item->y
                                );
                        int c = span_item->ucs;
                        if (0) {}

                        /* Escape XML special characters. */
                        else if (c == '<')  docx_char_append_string(content, "&lt;");
                        else if (c == '>')  docx_char_append_string(content, "&gt;");
                        else if (c == '&')  docx_char_append_string(content, "&amp;");
                        else if (c == '"')  docx_char_append_string(content, "&quot;");
                        else if (c == '\'') docx_char_append_string(content, "&apos;");

                        /* Expand ligatures. */
                        else if (c == 0xFB00) {
                            docx_char_append_string(content, "ff");
                        }
                        else if (c == 0xFB01) {
                            docx_char_append_string(content, "fi");
                        }
                        else if (c == 0xFB02) {
                            docx_char_append_string(content, "fl");
                        }
                        else if (c == 0xFB03) {
                            docx_char_append_string(content, "ffi");
                        }
                        else if (c == 0xFB04) {
                            docx_char_append_string(content, "ffl");
                        }

                        /* Output ASCII verbatim. */
                        else if (c >= 32 && c <= 127) {
                            docx_char_append_char(content, c);
                        }

                        /* Escape all other characters. */
                        else {
                            char    buffer[32];
                            snprintf(buffer, sizeof(buffer), "&#x%x;", c);
                            docx_char_append_string(content, buffer);
                        }
                    }
                    /* Remove any trailing '-' at end of line. */
                    docx_char_truncate_if(content, '-');
                }
            }
            if (0) fprintf(stderr, "\n");
            if (font_name) {
                docx_run_finish(content);
                font_name = NULL;
            }
            docx_paragraph_finish(content);
        }
    }
    ret = 0;

    end:

    if (in) fclose(in);

    if (ret) {
        int page_i;
        for (page_i=0; page_i<pages_num; ++page_i) {
            page_t* page = pages[page_i];
            if (page) {
                int para_i;
                for (para_i=0; para_i<page->paras_num; ++para_i) {
                    para_t* para = page->paras[para_i];
                    if (para) {
                        int l;
                        for (l=0; l<para->lines_num; ++l) {
                            line_t* line = para->lines[l];
                            if (line) {
                                int s;
                                for (s=0; s<line->spans_num; ++s) {
                                    span_t* span = line->spans[s];
                                    free(span->items);
                                }
                                free(line->spans);
                            }
                            free(line);
                        }
                    }
                    free(para);
                }
            }
            free(page);
        }
        free(pages);
    }

    return ret;
}







/* Things to allow creation of a fz_context*. */

pthread_mutex_t     m_mutexes[FZ_LOCK_MAX];
fz_locks_context    m_locks;

static void lock(void *user, int lock)
{
    pthread_mutex_lock(&m_mutexes[lock]);
}

static void unlock(void *user, int lock)
{
    pthread_mutex_unlock(&m_mutexes[lock]);
}





int main(int argc, char** argv)
{
    const char* docx_out_path       = NULL;
    const char* input_path          = NULL;
    const char* docx_template_path  = NULL;
    const char* content_path        = NULL;
    int preserve_dir = 0;
    int use_stext = 0;

    for (int i=1; i<argc; ++i) {
        const char* arg = argv[i];
        if (!strcmp(arg, "-h") || !strcmp(arg, "--help")) {
            printf(
                    "Generates a .docx file.\n"
                    "\n"
                    "Input:\n"
                    "\n"
                    "    We require either a file containing XML output from mutool -F stext, or a .pdf"
                    "    file on which we run mutool.py -F stext ourselves."
                    "\n"
                    "    We also requires a template .docx file\n"
                    "\n"
                    "Args:\n"
                    "    -c <path>\n"
                    "        If specified, we write raw .docx content to <path>; this is the\n"
                    "        text that we embed inside the template word/document.xml file\n"
                    "        when generating the .docx.\n"
                    "    -i <input-path>\n"
                    "        Name of XML file containing low-level text spans.\n"
                    "    -o <docx-path>\n"
                    "        Output .docx file.\n"
                    "    -p 0|1\n"
                    "        If 1, we preserve uncompressed <docx-path>.lib/ directory.\n"
                    "    -s 0|1\n"
                    "        Use stext to do most of the extraction, instead of local routines.\n"
                    "    -t <docx-template>\n"
                    "        Name of docx file to use as template.\n"
                    );
        }
        else if (!strcmp(arg, "-c")) {
            content_path = argv[++i];
        }
        else if (!strcmp(arg, "-i")) {
            input_path = argv[++i];
        }
        else if (!strcmp(arg, "-o")) {
            docx_out_path = argv[++i];
        }
        else if (!strcmp(arg, "-p")) {
            preserve_dir = atoi(argv[++i]);
        }
        else if (!strcmp(arg, "-s")) {
            use_stext = atoi(argv[++i]);
        }
        else if (!strcmp(arg, "-t")) {
            docx_template_path = argv[++i];
        }
        else {
            printf("Unrecognised arg: '%s'\n", arg);
            return 1;
        }

        assert(i < argc);
    }

    assert(input_path);
    assert(docx_out_path);
    assert(docx_template_path);

    int e;
    char* content;

    if (use_stext) {
        fprintf(stderr, "Using stext to do main extraction\n");
        m_locks.user = NULL;
        m_locks.lock = lock;
        m_locks.unlock = unlock;
        int i;
        for (i=0; i<FZ_LOCK_MAX; ++i) {
            pthread_mutex_init(&m_mutexes[i], NULL /*attr*/);
        }
        fz_context* ctx = fz_new_context(NULL /*alloc*/, &m_locks, FZ_STORE_DEFAULT);

        fz_stext_device* dev = spans_to_stext_device(ctx, input_path);

        page_to_docx_content(ctx, dev->page, &content);
    }
    else {
        spans_to_docx_content(input_path, &content);
    }

    if (content_path) {
        fprintf(stderr, "Writing content to: %s\n", content_path);
        FILE* f = fopen(content_path, "w");
        assert(f);
        fwrite(content, strlen(content), 1 /*nmemb*/, f);
        fclose(f);
    }
    fprintf(stderr, "Creating .docx file: %s\n", docx_out_path);
    e = create_docx(content, docx_out_path, docx_template_path, preserve_dir);

    return e;
}
